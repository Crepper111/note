# 树链剖分
# $Heavy\ Path\ Decomposition$
## 概念

**重儿子**：子节点中子树最大的节点

**轻儿子**：剩下的节点

从这个结点到重儿子的边为**重边**。

到其他轻儿子的边为**轻边**。

**重链**：重边连成链

**轻链**：轻边连成链

把落单的结点也当作重链，那么整棵树就被剖分成若干条重链。

**树链剖分**（一般指**重链剖分**）就是将树解剖成一条条链。

如图：
![heavy-path-decomposition](https://s2.loli.net/2023/09/24/hot7cF1r9EvXqSn.png)

## 性质
### 可以将树上任意一条路径分成不超过$O(logn)$条重链

- 如果进行一个重儿子优先搜索，重链在搜索序上是连续的
- 对于任意两点间的路径，又可以在其LCA处分成两条链

所以

## 用途
- 可以用数据结构在dfn上维护这$O(logn)$条链，时间复杂度$O(nlog^2n)$
- 当然也可以求LCA，时间复杂度$O(n)$

## 实现

### 预处理

因为求dfn序需要先知道重儿子，所以需要两遍dfs。

```cpp
fa[u]   u的父亲
son[u]  u的重儿子
sz[u]   u的子树大小
dfn[u]  u的搜索序
top[u]  u所在链的链头
nfd[u]  搜索序为u的节点
dep[u]  u的深度
```
```cpp
void dfs1(int x,int ft)                      //ft是父亲 
{
	fa[x]=ft;
	sz[x]=1;                                 //子树的大小要把根节点算进去 
	dep[x]=dep[ft]+1;
	for(auto to:v[x])
	{
		if(to==ft) continue;
		dfs1(to,x);                          //搜索子树 
		sz[x]+=sz[to];
		son[x]=sz[to]>sz[son[x]]?to:son[x];  //更新重儿子 
	}
}
```
```cpp
void dfs2(int x,int tp)                      //tp是当前重链的链头 
{
	dfn[x]=++cnt;                            //更新搜索序 
	nfd[cnt]=x;
	top[x]=tp;
	if(son[x]) dfs2(son[x],tp);              //优先搜索重儿子，注意要先判断有没有 
	for(auto to:v[x])
	{
		if(to==fa[x]||to==son[x]) continue;  //不要搜两遍重儿子 
		dfs2(to,to);
	}
}
```
### 如何维护
1. 选择一个所在链链头更深的节点
2. 将这个节点跳至其链头的父节点
3. 重复1-2步，直到两点在一条链上
4. 最后两者中深度低的点就是其LCA

- 如果需要维护链值，每次跳之前，可以处理$dfn[top_x]-dfn[x]$的区间，由于树剖的性质，这个区间在dfn上肯定是连续的。

代码
```cpp
void chain_work(int x,int y)                    //x,y是链的端点 
{
	while(top[x]!=top[y])                       //如果不在一条链上 
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);  //找出更深的点 
		work(dfn[top[x]],dfn[x]);               //处理区间 
		x=fa[top[x]];                           //向上一条链跳 
	}
	if(dep[x]>dep[y]) swap(x,y);                //同一条链上，深度小的节点dfn序肯定靠前 
	work(dfn[x],dfn[y]);                        //不要忘记最后同一条链上的路径 
	return;
}
```
## 例题
### [P3384 【模板】重链剖分/树链剖分](https://www.luogu.com.cn/problem/P3384)

需要维护：
1. 链加
2. 链求和
3. 子树加
4. 子树求和

已经很显然了，前两项用树剖+线段树维护，由于树剖仍是dfs，所以搜索序也满足dfs的性质（同一子树区间连续），所以后两项可以顺便维护。

时间复杂度
- 前两项$O(nlog^2n)$
- 后两项$O(nlogn)$

#### 代码：

头文件与全局变量：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#define SET(a,b) memset(a,b,sizeof(a))
using namespace std;
int read(){int readF=1,readK=0;char readC=getchar();while(readC<'0'||readC>'9'){if(readC=='-')readF=-1;readC=getchar();}while(readC>='0'&&readC<='9'){readK=readK*10+readC-'0';readC=getchar();}return readF*readK;}
int read(int &T){int readF=1,readK=0;char readC=getchar();while(readC<'0'||readC>'9'){if(readC=='-')readF=-1;readC=getchar();}while(readC>='0'&&readC<='9'){readK=readK*10+readC-'0';readC=getchar();}return T=readF*readK;}
const int N=1e5+10;
int n,m,R,mod;
int a[N];
vector <int> v[N];
```
树链剖分：
```cpp
int fa[N],son[N],sz[N],dfn[N],cnt,top[N],nfd[N],dep[N];
void dfs1(int x,int ft)
{
	fa[x]=ft;
	sz[x]=1;
	dep[x]=dep[ft]+1;
	for(auto to:v[x])
	{
		if(to==ft) continue;
		dfs1(to,x);
		sz[x]+=sz[to];
		son[x]=sz[to]>sz[son[x]]?to:son[x];
	}
}
void dfs2(int x,int tp)
{
	dfn[x]=++cnt;
	nfd[cnt]=x;
	top[x]=tp;
	if(son[x]) dfs2(son[x],tp);
	for(auto to:v[x])
	{
		if(to==fa[x]||to==son[x]) continue;
		dfs2(to,to);
	}
}
```
线段树：
```cpp
#define mid ((l+r)/2)
#define ls (id*2)
#define rs (id*2+1)
int t[N*4],lazy[N*4];
void push_up(int id)
{
	t[id]=t[ls]+t[rs];
	t[id]%=mod;
}
void build(int id,int l,int r)
{
	if(l==r)
	{
		t[id]=a[nfd[l]]%mod;//建树时别把节点搞成初始节点
		return;
	}
	build(ls,l,mid);
	build(rs,mid+1,r);
	push_up(id);
}
void push_down(int id,int l,int r)
{
	(lazy[ls]+=lazy[id])%=mod;
	(lazy[rs]+=lazy[id])%=mod;
	(t[ls]+=lazy[id]*(mid-l+1))%=mod;
	(t[rs]+=lazy[id]*(r-mid))%=mod;
	lazy[id]=0;
}
// l,r 是当前子树区间，x,y 是查找的区间，别搞错了
void add(int id,int l,int r,int x,int y,int val)
{
	if(x<=l&&r<=y)
	{
		(lazy[id]+=val)%=mod;
		(t[id]+=val*(r-l+1))%=mod;
		return;
	}
	push_down(id,l,r);
	if(x<=mid) add(ls,l,mid,x,y,val);
	if(y>mid) add(rs,mid+1,r,x,y,val);
	push_up(id);
}
int find(int id,int l,int r,int x,int y)
{
	if(x<=l&&r<=y)
	{
		return t[id];
	}
	push_down(id,l,r);
	int ans=0;
	if(x<=mid) (ans+=find(ls,l,mid,x,y))%=mod;
	if(y>mid) (ans+=find(rs,mid+1,r,x,y))%=mod;
	return ans;
}
```
操作函数：
```cpp
void chain_add(int x,int y,int val)                  //链修改 
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		add(1,1,n,dfn[top[x]],dfn[x],val);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	add(1,1,n,dfn[x],dfn[y],val);
	return;
}
void chain_find(int x,int y)                         //链查询 
{
	int ans=0;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		(ans+=find(1,1,n,dfn[top[x]],dfn[x]))%=mod;
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	(ans+=find(1,1,n,dfn[x],dfn[y]))%=mod;
	printf("%d\n",ans);
	return;
}
void tree_add(int x,int val)                         //子树修改 
{
	add(1,1,n,dfn[x],dfn[x]+sz[x]-1,val);
}
void tree_find(int x)                                //子树查询 
{
	printf("%d\n",find(1,1,n,dfn[x],dfn[x]+sz[x]-1));
}
```
主函数：
```cpp
signed main()
{
	scanf("%d%d%d%d",&n,&m,&R,&mod);            //读入 
	for(int i=1;i<=n;i++) read(a[i]);
	for(int i=1;i<n;i++)
	{
		int x=read(),y=read();
		v[x].push_back(y);                      //建树 
		v[y].push_back(x);
	} 
	dfs1(R,0);                                  //树剖 
	dfs2(R,R);
	build(1,1,n);                               //建线段树 
	for(int i=1;i<=m;i++)
	{
		int o=read(),x,y,z;
		switch(o)                               //work
		{
			case 1:
				x=read(),y=read(),z=read();
				chain_add(x,y,z);
				break;
			case 2:
				x=read(),y=read();
				chain_find(x,y);
				break;
			case 3:
				x=read(),z=read();
				tree_add(x,z);
				break;
			case 4:
				x=read();
				tree_find(x);
				break;
		}
	}
	return 0;
}
```

**The End**