## 扫描线

扫描线，是一种思想，求矩形的面积并时，可以考虑有一条平行于纵轴的线，这条线从左往右移动，线从一个竖边移向另一个竖边，于是可以把整个图形分成一个个竖着的，互不重叠的矩形，扫描时，矩形在扫描线上的投影就是矩形的长度（不一定连续），竖线间的间距就是宽度。

![QQ截图20231026113209.png](https://s2.loli.net/2023/10/26/vE9RtIOfc8u1PLa.png)

### 如何维护？

可以用线段树维护扫描线上被矩形覆盖的区间长度

每当一个矩形“进入”扫描线时，将它覆盖的区间整体加1，当扫描线出来后，再将这段区间整体减1。

这样,值>0的区间会对矩形面积有贡献,再维护这样的区间总长len即可

在具体实现上,可以把矩形拆成一个个竖线维护,记录是“入边”还是“出边”（tag=1/-1）把它们按照横坐标排序即可计算。

- 值域较大，需要动态开点。（根据大佬的指点，空间需要开$\lceil nlogn\rceil$）

### [P5490 【模板】扫描线](https://www.luogu.com.cn/problem/P5490)

## code

竖线：
```cpp
struct line
{
	int b,h;			//下端点和上端点坐标 
	int tag;
	int x;				//横坐标 
}li[N];
bool cmp(line x,line y)
{
	return x.x<y.x;
}
```

线段树：

`cover`：这个区间有没有被完全覆盖

`len`：区间总长

```cpp
struct tree
{
	int l,r;
	int cover;		//区间有没有被完全覆盖，被覆盖了几次
	int len;		//被覆盖区间总长
	int lson,rson; 
	int ls();
	int rs();
	
}t[N*32]; 			//此题n为2e5（每个矩形两条竖边），logn约为34，但是开32能过 
int tot=1;
int tree::ls()
{
	int mid=(l+r)/2;
	if(!lson)
	{
		lson=++tot;
		t[tot].l=l;
		t[tot].r=mid;
	}
	return lson;
}
int tree::rs()
{
	int mid=(l+r)/2;
	if(!rson)
	{
		rson=++tot;
		t[tot].l=mid+1;
		t[tot].r=r;
	}
	return rson;
}
void push_up(int id)
{
	int l=t[id].l,r=t[id].r;
	
	if(t[id].cover) t[id].len=r-l+1;					//如果被完全覆盖就是区间长度 
	else t[id].len=t[t[id].lson].len+t[t[id].rson].len;	//否则从子区间更新 
}														//这里不能用开点函数，要不然会玄学MLE 
void add(int id,int x,int y,int val)
{
	int l=t[id].l,r=t[id].r;
	
	if(x<=l&&y>=r)
	{
		t[id].cover+=val;
		push_up(id);									//与一般线段树不同，这里需要push_up更新len 
		return;
	} 
	int mid=(l+r)/2;
	if(x<=mid) add(t[id].ls(),x,y,val);
	if(y>mid) add(t[id].rs(),x,y,val);
	push_up(id);
  	//线段树好闪，拜谢线段树！
}
```

main:
```cpp
int main()
{
	read(n);
	for(int i=1;i<=n;i++)
	{
		int h,b,l,r;
		scanf("%d%d%d%d",&l,&h,&r,&b);
		if(l>r) swap(l,r);										//别把区间端点搞反了 
		if(h<b) swap(h,b);
		li[2*i-1]=(line){b,h,1,l};
		li[2*i]=(line){b,h,-1,r};
	}
	sort(li+1,li+n*2+1,cmp);									//按照横坐标排序 
	t[1].l=0,t[1].r=1e9+5;										//线段树的根，表示整个值域 
	long long ans=0;											//。 
	for(int i=1;i<=2*n;i++)
	{
		ans+=(long long)t[1].len*(long long)(li[i].x-li[i-1].x);//用总覆盖长度乘两条线的间距，就是这一段小矩形的面积 
		add(1,li[i].b+1,li[i].h,li[i].tag);						//先计算上一段面积，再更新扫描线 
	}
	printf("%lld",ans);
    return 0;
}
```
### 重要问题

- **为什么更新扫描线时，竖线下端点坐标需要+1？**

给出的坐标其实是个“边界坐标”，有一种“左开右闭”的性质，而我们只会用线段树计算闭区间的长度，所以要把左端点（下端点）+1。

- **线段树明明要区间加，为什么没有类似push_down的操作？**

我们发现，扫描线只需要用到整个区间的覆盖长度，即只调用根节点的len，这样保证了我们只会查找被完全覆盖的大区间，更新时，也是从根节点向下寻找，而不会去查找这种大区间的子区间。也就是说，我们**不需要向更小的子区间负责**，只需要push_up更新大区间即可，push_down是用来对付查找琐碎区间的操作的，故我们不需要push_down