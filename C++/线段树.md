# $\Huge{Segment-Tree}$
# $\color{red}\text{线段树好闪，拜谢线段树！}$
## 支持在线区间查询、修改的数据结构
- 时间复杂度一般为$O(log_2n)$
- 常数巨大

![segment_tree.png](https://s2.loli.net/2023/09/24/DJpxHnY59uAQEwP.png)

- 线段树是一棵二叉树，可以维护区间和、最值等内容。
- 内存一般开4*N
- 以下内容以维护区间和为例

## 建立
**因为常数巨大，不使用单点插入建树**
```cpp
#define mid ((l+r)/2)  // mid划分左右区间 
#define ls (id*2)      // id是根结点，二叉树的性质得到左右子树 
#define rs (id*2+1)  

//节点编号为id，代表[l,r]的区间
void build(int id,int l,int r)
{
	if(l==r)           //如果是叶子节点，区间长为一 
	{
		t[id]=a[l];    //a是初始数组 
		return;
	}
	build(ls,l,mid);   //建左子树 
	build(rs,mid+1,r); //建右子树 
	t[id]=t[ls]+t[rs]; //建自己 
}

build(1,1,n);          //整棵线段树的根是1，区间是1~n

```
## 区间修改
**懒标记**：记录一个完整区间加了多少值，在需要向子区间赋值或查找时再将标记下放(push_down)。

我们定义对于节点id，其懒标记的值为自己已实际加上（乘上），但子节点未实际加上的值。

下放到子结点后，根节点的标记会被清除。


```cpp
void push_down(int id,int l,int r)
{
	lazy[ls]+=lazy[id];        //左节点下放 
	lazy[rs]+=lazy[id];        //右节点下放 
	t[ls]+=(mid-l+1)*lazy[id]; //左区间和=左区间长*每个元素加上的值 
	t[rs]+=(r-mid)*lazy[id];   //右区间同理 
	lazy[id]=0;                //不要忘记清空根的标记 
}
//将区间[x,y]内每个元素加上v 
void add(int id,int l,int r,int x,int y,int v)
{
	if(l>=x&&r<=y)             //如果被包含，就不需要往子区间更新 
	{
		lazy[id]+=v;
		t[id]+=v*(r-l+1);      
		return;                //更新完自己返回即可 
	}
	push_down(id,l,r);         //如果不被包含，就下放标记 
	if(x<=mid)                 //是否涉及左区间 
		add(ls,l,mid,x,y,v);
	if(y>mid)                  //是否涉及右区间 
		add(rs,mid+1,r,x,y,v);
	t[id]=t[ls]+t[rs];         //最后再更新自己 
}

```

## 区间查找

了解区间赋值后，查找就不难了

```cpp
//查找区间[x,y]的和 
int find(int id,int l,int r,int x,int y)
{
	if(l>=x&&r<=y)
	{
		return t[id];            //如果被完全包含就返回 
	}
	push_down(id,l,r);           //在找子区间前一定记得下放标记 
	int ans=0;
	if(x<=mid)
		ans+=find(ls,l,mid,x,y); 
	if(y>mid)
		ans+=find(rs,mid+1,r,x,y);
	return ans;
}
```
这样会把查找的区间不重不漏地算出来，由代码可知，返回的值都是被查找区间完全包含的，不会多算；在递归的过程中，要么返回区间本身，要么返回两个子区间的和，不会出现重复的情况。

### PS

[P3373 【模板】线段树 2](https://www.luogu.com.cn/problem/P3373)

当需要多种区间操作该如何打lazy

- 乘法的lazy初始为1
- 先乘后加
- 每找到一个结点，先 pushdown

	注意：先pushdown是为了写代码方便，但是如果结点是叶子时就没法pushdown，所以应该加上特判；同样，线段树1也可以先pushdown，也要特判。

- pushdown 是用父结点的lazy更新子结点的lazy和值

------------

## 动态开点

有时候我们的区间长度比较大，而区间个数却不多，直接建立线段树，会有许多琐碎区间用不上，浪费了许多空间，这时候就用到了动态开点这种高级东西。

- **当我们用到这个区间时，再开点**

所以需要对于每个节点，单独记录他的左右儿子。

并不需要太大的改动，无非是用到左右儿子时调用一个函数，已经开了就用，否则就新开一个点

- 内存至少要开$\lceil nlogn\rceil$（n是区间个数）

### 代码
```cpp
struct tree
{
	int l,r;
	int len;
	int lson,rson; 
	int ls();
	int rs();
	
}t[NlogN];
int tot=1;
int tree::ls()
{
	int mid=(l+r)/2;
	if(!lson)
	{
		lson=++tot;
		t[tot].l=l;
		t[tot].r=mid;
	}
	return lson;
}
int tree::rs()
{
	int mid=(l+r)/2;
	if(!rson)
	{
		rson=++tot;
		t[tot].l=mid+1;
		t[tot].r=r;
	}
	return rson;
}
``` 

**The End**