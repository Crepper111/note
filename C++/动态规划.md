# 动态规划笔记
## DP基本思路
1. 定义状态。

2. 写出状态转移式。

3. 根据状态转移式找出递推顺序。

4. 处理递推的边界。

5. 找出结果。

注意事项：**一定要设好初值！**


------------

### 线性动态规划
- 定义经常是“ $f_i$ 表示前 $i$ 个满足要求时的答案”，转移式通常只需要考虑最后一点。

### 区间dp
- 状态通常定义为“f[i][j]表示在区间[i,j]中满足要求的答案”，递推顺序由小区间向大区间，在区间中枚举断点，通常长度为1的区间会提前预处理。

    板子：
    ```cpp
    for(int len=2;len<=n;len++)
	{
		for(int i=1;i+len-1<=n;i++)
		{
			int j=i+len-1;
			for(int k=i;k<j;k++)
			{
				//状态转移方程
			}
		}
	}
    ```
### 树上/图上dp

- 一般使用dfs或拓扑排序

- 有环可以用tarjan缩点后处理

**树上背包**

- 边界难以判断

板子(vector存图)：
```
f[x][y]      以x为子树，消耗y的重量能获得的最大价值 
w[x],v[x]    x节点的重量、价值 
m            最大重量
```
```cpp
void dfs(int x)
{
	for(int i=w[x];i<=m;i++) f[x][i]=v[x]; 
//容量大于自身重量的情况，一开始都可以获得自己本身的价值，必须加，不然会出问题
	for(auto to:e[x])
	{
		dfs(to);
		for(int i=m;i>=0;i--)
			for(int j=0;j<=i;j++)
				f[x][i]=max(f[x][i],f[x][i-j]+f[to][j]);
	}
} 
```
外层由大到小，内层由小到大避免重复计算

**依赖背包**

- 选择父节点才可以选子节点

代码只需进行小小的改动：
```cpp
void dfs(int x)
{
	for(int i=w[x];i<=m;i++) f[x][i]=v[x];
	for(auto to:p[x])
	{
		dfs(to);
		for(int i=m;i>=w[x];i--)
		{
			for(int j=0;j<=i-w[x];j++)
			{
				f[x][i]=max(f[x][i],f[x][i-j]+f[to][j]);
			}
		}
	}
}
```
`j<=i-w[x]` ：相当于 `i-j>=w[x]` ，即不会从<w[x]重量处转移（选择x至少要承受w[x]的重量）

`i>=w[x]` ：也是保证自己至少要承受w[x]重量


